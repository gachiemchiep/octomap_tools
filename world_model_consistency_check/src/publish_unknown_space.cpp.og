#include <octomap/AbstractOcTree.h>
#include <octomap_msgs/Octomap.h>
#include <octomap_msgs/conversions.h>
#include <octomap/octomap.h>
#include <octomap/OcTree.h>
#include <ros/ros.h>
#include <std_msgs/String.h>
#include <visualization_msgs/MarkerArray.h>

#include <pcl/point_cloud.h>
#include <pcl/point_types.h>
#include <pcl_ros/point_cloud.h>

using namespace std;
using namespace octomap;
using namespace octomap_msgs;

AbstractOcTree *tree = NULL;
OcTree *octree = NULL;
ros::Publisher marker_pub;
ros::Publisher cloud_pub;

void octomapCallback(const octomap_msgs::Octomap::ConstPtr &msg)
{
    if (octree != NULL)
    {
        // ROS_INFO("DEBUG: Going to DEL OCTREE");
        delete (octree);
        // ROS_INFO("DEBUG: Octree DEL");
    }

    tree = msgToMap(*msg);
    octree = dynamic_cast<OcTree *>(tree);

    string frame_id = "/base_link";
    ros::Time t = ros::Time::now();

    point3d min;
    min.x() = -0.5;
    min.y() = -0.5;
    min.z() = -0.5;

    point3d max;
    max.x() = 0.5;
    max.y() = 0.5;
    max.z() = 0.5;

    ros::param::get("~min_x", min.x());
    ros::param::get("~min_y", min.y());
    ros::param::get("~min_z", min.z());

    ros::param::get("~max_x", max.x());
    ros::param::get("~max_y", max.y());
    ros::param::get("~max_z", max.z());

    //ros::param::get("~resolution", resolution);
    ros::param::get("~fixed_frame", frame_id);

    visualization_msgs::MarkerArray unknown_nodes;
    point3d_list unknown_centers;
    pcl::PointCloud<pcl::PointXYZRGBA> unknown_pc;
    sensor_msgs::PointCloud2 unknown_cloud;

    octree->getUnknownLeafCenters(unknown_centers, min, max, 0);

    int treeDepth = octree->getTreeDepth();
    double resolution = octree->getResolution();

    // double prob_hit = octree -> getProbHit();
    // double prob_miss = octree -> getProbMiss();
    // double clampingTmin = octree -> getClampingThresMin();
    // double clampingTmax = octree -> getClampingThresMax();

    int num_of_unknown_cells = unknown_centers.size();
    unknown_nodes.markers.resize(num_of_unknown_cells);

    ROS_INFO("Total unknown centers: %d", num_of_unknown_cells);

    int id = 0;

    //TODO: check segmentation fault
    // KeySet unknownCells;
    // octomap::OcTree *unknownOcTree = NULL;
    // unknownOcTree->setResolution(resolution);

    for (point3d_list::iterator it = unknown_centers.begin(); it != unknown_centers.end(); ++it)
    {
        geometry_msgs::Point cubeCenter;
        cubeCenter.x = it->octomath::Vector3::x();
        cubeCenter.y = it->octomath::Vector3::y();
        cubeCenter.z = it->octomath::Vector3::z();
        unknown_nodes.markers[id].points.push_back(cubeCenter);
        id++;

        pcl::PointXYZRGBA unknown_leaf_center_point;
        unknown_leaf_center_point.x = it->octomath::Vector3::x();
        unknown_leaf_center_point.y = it->octomath::Vector3::y();
        unknown_leaf_center_point.z = it->octomath::Vector3::z();
        unknown_leaf_center_point.r = 1.0 * 255;
        unknown_leaf_center_point.g = 0.6 * 255;
        unknown_leaf_center_point.b = 0.0 * 255;
        unknown_leaf_center_point.a = 1.0 * 255;
        unknown_pc.push_back(unknown_leaf_center_point);

        // point3d insertionPoint(it->octomath::Vector3::x(), it->octomath::Vector3::y(), it->octomath::Vector3::z());
        // OcTreeKey nodeKey = unknownOcTree.coordToKey(insertionPoint);
        // unknownCells.insert(nodeKey);
    }

    ROS_INFO("Points centers added: %d", id);
    id = 0;

    pcl::toROSMsg(unknown_pc, unknown_cloud);
    unknown_cloud.header.frame_id = frame_id;
    unknown_cloud.header.stamp = t;

    // for (KeySet::iterator it = unknownCells.begin(), end = unknownCells.end(); it != end; ++it)
    // {
    //     unknownOcTree.updateNode(*it, false);
    // }

    
    for (point3d_list::iterator it = unknown_centers.begin(); it != unknown_centers.end(); ++it)
    {

        unknown_nodes.markers[id].ns = "boxes";
        unknown_nodes.markers[id].header.frame_id = frame_id;
        unknown_nodes.markers[id].header.stamp = t;
        // unknown_nodes.markers[id].action = visualization_msgs::Marker::ADD;
        unknown_nodes.markers[id].id = id;
        unknown_nodes.markers[id].type = visualization_msgs::Marker::CUBE_LIST;
        unknown_nodes.markers[id].scale.x = resolution;
        unknown_nodes.markers[id].scale.y = resolution;
        unknown_nodes.markers[id].scale.z = resolution;
        unknown_nodes.markers[id].color.r = 1.0;
        unknown_nodes.markers[id].color.g = 0.6;
        unknown_nodes.markers[id].color.b = 0.0;
        unknown_nodes.markers[id].color.a = 1;

        if (unknown_nodes.markers[id].points.size() > 0)
        {
            unknown_nodes.markers[id].action = visualization_msgs::Marker::ADD;
        }
        else
        {
            unknown_nodes.markers[id].action = visualization_msgs::Marker::DELETE;
        }

        id++;
    }
    

    cloud_pub.publish(unknown_cloud);
    marker_pub.publish(unknown_nodes);
    ROS_INFO("Cubes created: %d", id);
}

int main(int argc, char **argv)
{
    ros::init(argc, argv, "unknown_space_node");
    ros::NodeHandle nh;

    double rate = 1;
    ros::param::get("~rate", rate);

    ros::Duration(0.5).sleep();

    ros::Subscriber sub = nh.subscribe("/octomap_full", 1, octomapCallback);
    marker_pub = nh.advertise<visualization_msgs::MarkerArray>("/unknown_cells_vis_array", 1);

    cloud_pub = nh.advertise<sensor_msgs::PointCloud2>("/unknown_pc", 1);

    ros::Rate loop_rate(rate);

    while (ros::ok())
    {
        ros::spinOnce();
        loop_rate.sleep();
    }

    return 0;
}
